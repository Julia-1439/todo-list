/* ========================================================================== */
/* Storage Controller */
/* ========================================================================== */
IMPORT { TodoItem } from "todoItem.js"
IMPORT { Project } from "project.js"

SET classes TO [ChecklistItem, TodoItem, Project]
// An object containing key-value pairs of class names to classes
SET classAccessor TO Object.fromEntries(classes.map((c) => [c.name, c]))

FUNC isStorageAvailable() 
  RETURN {Boolean} whether localStorage is available, implemented per MDN's example

// item {Project | TodoItem | ChecklistItem}
FUNC serialize(item):
  SET item.createdBy TO item.constructor.name
  CALL classAccessor.creator.dehydrate(item)
  CALL JSON.stringify WITH item INTO serializedItem
  RETURN {String} serializedItem

// value {String}
FUNC deserialize([key, value]):
  CALL JSON.parse WITH value INTO deserializedItem
  CREATE the item USING new classAccessor.creator.rehydrate(val, key) INTO item
  RETURN item

// Create a new entry or Update an existing entry 
FUNC post(item)
   CALL serialize WITH item
   CALL localStorage.setItem WITH key as uuid AND value as serilization

// Get item from localStorage of type {Project | TodoItem | ChecklistItem}
FUNC get(uuid)
  CALL localStorage.getItem WITH uuid INTO value
  IF value is non-null:
    CALL deserialize(uuid, value) on value INTO item 
  RETURN item

FUNC delete(uuid)
  CALL localStorage.removeItem WITH uuid

// @TODO how do you connect it all back together???
// PURPOSE: called once on page load
FUNC getAllProjects()
  REHYDRATE every item in localStorage USING get
  FOR EACH project:
    ITERATE 

EXPORT:
  getAllProjects
  post
  delete
  // ? maybe I should work on internalController first. 


/* ========================================================================== */
/* class Project: */
/* ========================================================================== */


static instanceReviver(objProject, uuid)
  CALL new Project WITH title, description from objProject INTO project
  SET project.status TO objProject._status.name
  FOR EACH objTodo in objProject.todoList:
    CALL TodoItem.instanceReviver(objTodo, objTodo.uuidToInject) INTO todo
    CALL project.addTodo(todo)
  RETURN project

/* ========================================================================== */
/* Internal Controller */
/* ========================================================================== */

Modeled off Todoist
This module offers an interface for the user to crud projects & todos. For each action taken, the corresponding action is done on localStorage via storageController. 

IMPORT {Project, TodoItem, storageController}
EXPORT {initialize, all crud operations for Project and TodoItem}

SET private const _projects TO empty array 

private func restoreFromStorage(): restores _projects by calling storageController
  CALL storageController.getAll() INTO projectsFromStorage
  CALL projectsFromStorage.forEach((project) => _projects.push(project))

private func createDefaultProject(): create a 'Home' project and put two sample todos in there
  CALL createProject WITH {title: "Home"}
  SET project TO _projects[0] 
  CALL createTodo WITH project.uuid and {
    title: "Buy groceries", 
    description: "Go to the big store to buy some big groceries", 
    dueDateTime: new Date(4pm tomorrow), 
    priorityLevel: "p2"
  }
  CALL createTodo WITH project.uuid and {
    title: "Take a relaxing bath", 
    description: "Use bubbles!", 
    dueDateTime: new Date(7pm next Friday), 
    priorityLevel: "p3"
  }

private func viewAllProjects(): returns an array of the projects with title strings only. for usage in the sidebar to display all projects
    RETURN _projects.map(project => project.title)

func initialize(): called on page load to prepare the space (the SR) - restore projects from storage; if no projects exist or localStorage not available, create a default one; return the project names for the sidebar
    CALL restoreFromStorage()
    IF _projects.length === 0:
      CALL createDefaultProject()
    RETURN viewAllProjects()

// @param projectMetadata {Object} see createTodo for why it's like this
C func createProject(projectMetadata):
    SET {title, description} USING destructuring syntax on projectMetadata
    CALL new Project WITH title, description INTO project
    CALL _projects.push WITH project

    CALL storageController.post WITH project

R func viewProject(uuid): brings up a full-page view of the project including its todos
    CALL _projects.find WITH uuid INTO project
    CALL Project.view(project) INTO returnObj
    RETURN returnObj

// @param projectMetadata {Object} see editTodoMetadata for why it's like this
U func editProjectMetadata(uuid, projectMetadata) 
    CALL _projects.find WITH uuid INTO project

    SET {title, description} USING destructuring syntax on projectMetadata
    FOR EACH defined field:
      SET project.field TO field

    CALL storageController.post WITH project

D func deleteProject(uuid)
    CALL _projects.findIndex WITH uuid INTO removalIdx
    CALL _projects.splice WITH removalIdx 
    CALL storageController.remove WITH uuid

@param todoMetadata {Object} object holding arguments for the TodoItem constructor. do it this way to avoid the display controller needing to have "knowledge" of what arguments are submitted; "why should displayController have to change if I change Project?". instead, we just need to modify the intake form and the call to new TodoItem; rather than intake form, the argument list in calling addTodo, and the addTodo parameter list definition. this implementation will use the Object.fromEntries(FormData.entries()) to create an object containing the arguments
C func addTodo(projectUuid, todoMetadata)
    CALL _projects.find WITH projectUuid INTO project

    SET {title, description, dueDateTime, priorityLevel} USING destructuring syntax on todoMetadata
    CALL new TodoItem WITH title, description, dueDateTime, priorityLevel INTO todo
    CALL project.addTodo WITH todo

    CALL storageController.post WITH project
    
// note that the summary displaying is handled by viewProject
R func expandTodo(projectUuid, todoUuid): additionally gives the description
    CALL _projects.find WITH projectUuid INTO project
    CALL project.todoList.find WITH todoUuid INTO todo

    RETURN TodoItem.details(todo)

// @param data {Object} object holding arguments, probably from a FormData object if editing metadata or , similar to addTodo
U func editTodoMetadata(projectUuid, todoUuid, todoMetadata):
    CALL _projects.find WITH projectUuid INTO project
    CALL project.todoList.find WITH todoUuid INTO todo

    SET {title, description, dueDateTime, priorityLevel} USING destructuring syntax on todoMetadata
    FOR EACH defined field:
      SET todo.field TO field
    
    CALL storageController.post WITH project

D func deleteTodo(projectUuid, todoUuid)
    CALL _projects.find WITH projectUuid INTO project

    CALL project.removeTodo WITH todoUuid
    
    CALL storageController.post WITH project


/* ========================================================================== */
/* Display Controller */
/* ========================================================================== */

Perhaps a function that gets an updated view of this project, OR modify todo crud to retain the updated project.
Potential idea: an "archived" status

memo: editing:
  "title", 
  "description", 
  "dueDateTime", 
  "priority", 
  "status",

// UPDATING THE DISPLAY
wipe content
update main (probably done with R project)
update sidebar

// FUNCTIONALITY:
x PAGE LOAD:
- projects loaded from storage
- sidebar gets populated
- most recent project gets displayed

SIDEBAR:
- C add project 
- R view project
  for each project: 
  - U edit project (opens a dialog form)
  - D delete project (opens a dialog form to confirm)

MAIN:
viewing a project:
  for curr project:
  - U edit project (3-dot or change directly ('change' event?))
  - D delete project

  - C add a todo
  - R view all todos
  - R expand a todo (shows description)
  - U edit a todo (opens a dialog form)
  - D delete a todo (opens a dialog form to confirm)


/* ========================================================================== */
HELPERS
/* ========================================================================== */

// wipes the content of a div, for usage particularly with div#content 
/**
 * @param {HTMLElement} 
 * @returns {}
 */
func wipe(container)
  WHILE container.firstChild
    container.removeChild(container.lastChild)

/**
 * @param {String} notifMsg
 */
func displayNotif(notifMsg)
  // display the notification
  CALL notif.setAttribute TO unhide the notification
  SET notif.textContent TO notifMsg

  // hide the notification
  CALL setTimeOut WITH some seconds DO:
    CALL notif.setAttribute TO hide the notification 
    SET notif.textContent TO null

func updateSidebar()
  CALL internalControl.viewProjectTitles INTO projectTitles // @todo need to expose this
  CALL projectTitles.reverse() // put most recent projects first
  FOR EACH title OF projectTitles
    DOMCREATE button INTO projectBtn
    SET projectBtn.textContent TO projectTitle
    CALL nav.append WITH projectBtn

/* ========================================================================== */
VARIABLES
/* ========================================================================== */

SET doc TO document
SET projects TO doc.querySelector("#projects")
SET main TO doc.querySelector("#main")
SET notif TO doc.querySelector("#notif") // probably a non-modal dialog

/* ========================================================================== */
PAGE LOAD
/* ========================================================================== */

// Add event listeners to the page

/**
 * Preconditions: none
 * Postconditions: sidebar is populated with a button for each project.
 * main is populated with the latest project.  
 * @param {} 
 * @returns {}
 */
func load()
  // load the data from storage OR create a default project if no projects
  CALL internalControl.initialize() INTO loadData

  // populate the sidebar with the projects
  CALL updateSidebar
  
  // render the latest project
  CALL renderProject WITH loadData.latestProjectData

/* ========================================================================== */
CRUD projects
/* ========================================================================== */

/**
 * open a form to enter and submit data for a new project. 
 * Preconditions: a form is submitted with data to create a new project
 * Postconditions: a new project is created and main is populated with it
 * @param {Event {SubmitEvent}} a submitEvent with 'form' attribute set 
 * @returns {}
 */
func createProject(submitEvt)
  SET creationForm TO submitEvt.submitter.form
  SET creationData TO new FormData(creationForm)
  CALL internalControl.createProject WITH creationData INTO projectData

  // view it
  CALL renderProject WITH projectData
  CALL updateSidebar
  CALL displayNotif WITH a message

/**
 * Preconditions: none
 * Postconditions: main is populated with projectData, and its elements 
 * have dataset properties set including uuid.
 * @param {Object} 
 * @returns {}
 */
func renderProject(clickEvt=null, projectData=null)
  CALL wipe WITH main
  // ...

/**
 * Preconditions: none
 * Postconditions: main is populated with the updated projectData 
 * @param {SubmitEvent | Event with .type "change"}  
 * @returns {}
 */
func updateProject(evt)
  GET uuid FROM somewhere // @todo
  SET updatedData TO {}
  IF evt.type === "change":
    SET formCtrl TO evt.target
    SET propToUpdate TO formCtrl.name
    SET updatedData[propToUpdate] TO evt.target.value
  ELSE IF evt.type === "submit":
    SET updateForm TO evt.submitter.form
    SET updatedData TO new FormData(updateForm)
  ELSE  
    THROW "An unknown error occured lmao"

  CALL internalControl.editProjectMetadata WITH uuid, updatedData INTO projectData

  // view
  CALL renderProject WITH projectData
  CALL updateSidebar
  CALL displayNotif WITH a message

/**
 * Preconditions: none
 * Postconditions: The project is removed from the database and from view. 
 * There is no content in the main content view. 
 * @param {SubmitEvent}
 * @returns {}
 */
func removeProject(submitEvt)
  GET uuid FROM somewhere 
  CALL internalControl.removeProject(uuid)
  
  CALL wipe WITH main
  CALL updateSidebar
  CALL displayNotif WITH a message

/* ========================================================================== */
CRUD todos
/* ========================================================================== */

func createTodo(uuid)
  SET creationData TO formDataEvt.formData
  CALL internalControl.createProject WITH creationData INTO projectData

  // view it
  CALL renderProject WITH projectData
  CALL updateSidebar
  CALL displayNotif WITH a message


/* ========================================================================== */
PAGE CONTROLS
/* ========================================================================== */

// HOOKING UP: Create project and Update project buttons
SET addProjectBtn.dataset.operation TO "create"
SET editProjectBtn.dataset.operation TO "update"

// uhh what about adding the dynamic buttons. 
// lets start from the ground up? ...
SELECT addProjectBtn, editProjectBtn 
[addProjectBtn, editProjectBtn].forEach((triggerBtn) => {
  addEventListener("click", (evt) => {
    CALL showModal ON #cu-project-dialog
    SET op TO triggerBtn.dataset.operation
    #cu-project-dialog.querySelectorAll([data-operation]).forEach(
      SET ele.dataset.operation TO op
    )
    FOR EACH span[data-operation] CALLED s:
      SET s.textContent TO op
  })
}

SELECT (#cu-project-form .form-submit-btn)


// HOOKING UP: Setting a project to completed or incomplete
